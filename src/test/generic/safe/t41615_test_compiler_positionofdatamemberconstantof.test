## -*- mode:ulam -*-
#=t41615_test_compiler_positionofdatamemberconstantof
##
##  gen output: (5 times with 4 interleaved asserts)
##        Unsigned Arg: 5
#!
Exit status: -11
Ue_T : System { :System<> Int test() {  ChainRule insert;  Unsigned posOfAtom = 5u;  self ( posOfAtom )print . self ( posOfAtom 5u cast == )assert . constant ChainRule cCR = ChainRule.constantof;  constant Unsigned cPosOfAtom = 5u;  self ( 5u )print . self ( true )assert . Unsigned posOfAtom2 = 5u;  self ( posOfAtom2 )print . self ( posOfAtom2 5u cast == )assert . self ( insert ( )atomPos . )print . 0 cast return } }
Uq_System { <NOMAIN> }
Un_ChainRule { Bool(5) sp(false);  Atom mCodonToInsert(Atom);  <NOMAIN> }
##
##  First test of new of-operator: .positionof
## variations with class as a variable, a constant, inline constantof class, and implicit self,
##
#>T.ulam
 ulam 5;
element T : System{

  Int test(){
    ChainRule insert;
    Unsigned posOfAtom = insert.mCodonToInsert.positionof;
    print(posOfAtom);
    assert(posOfAtom==5u);

    constant ChainRule cCR = ChainRule.constantof;
    constant Unsigned cPosOfAtom = cCR.mCodonToInsert.positionof;
    print(cPosOfAtom);
    assert(cPosOfAtom==5u);

    Unsigned posOfAtom2 = ChainRule.constantof.mCodonToInsert.positionof;
    print(posOfAtom2);
    assert(posOfAtom2==5u);

    print(insert.atomPos());
    return 0;
  }
}


#:ChainRule.ulam
  ulam 5;
transient ChainRule {
  Bool(5) sp;
  Atom mCodonToInsert;
  Unsigned atomPos(){
    return mCodonToInsert.positionof;
  }
}

#:System.ulam
ulam 1;
quark System {
Void print(Unsigned arg) native;
Void print(Int arg) native;
Void print(Int(4) arg) native;
Void print(Int(3) arg) native;
Void print(Unary(3) arg) native;
Void print(Bool(3) arg) native;
Void assert(Bool b) native;
}

#.
